<html>
<head>
	<title>target</title>
</head>
<body>
	<!-- <div class="target"></div> -->
	<canvas id="game-board" width="300" height="300"></canvas>

	<script>
		function flatten (nestedArr) {
			return nestedArr.reduce(function (flatArr, arr) {
				return flatArr.concat(arr);
			});
		}

		function randomFromArr (arr) {
			var max = arr.length - 1;
			var randIndex = Math.round(Math.random() * max);
			return arr[randIndex];
		}

		function pieceFactory (shape, color) {
			var line = {};
			var block = {};
			var s = {};
			var z = {};
			var l = {};
			var j = {};
			var t = {};

			line.color = "orange";
			line.rotations = [
				[
					[0, 0, 0, 1],
					[0, 0, 0, 1],
					[0, 0, 0, 1],
					[0, 0, 0, 1]
				],
				[
					[0, 0, 0, 0],
					[0, 0, 0, 0],
					[1, 1, 1, 1],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 1],
					[0, 0, 0, 1],
					[0, 0, 0, 1],
					[0, 0, 0, 1]
				],
				[
					[0, 0, 0, 0],
					[0, 0, 0, 0],
					[1, 1, 1, 1],
					[0, 0, 0, 0]
				],
			];

			block.color = "red";
			block.rotations = [
				[
					[0, 0, 0, 0],
					[0, 1, 1, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 1, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 1, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 1, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				]
			];

			s.color = "blue";
			s.rotations = [
				[
					[0, 1, 0, 0],
					[0, 1, 1, 0],
					[0, 0, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 1, 0],
					[1, 1, 0, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 1, 0, 0],
					[0, 1, 1, 0],
					[0, 0, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 1, 0],
					[1, 1, 0, 0],
					[0, 0, 0, 0]
				]
			];

			z.color = "green";
			z.rotations = [
				[
					[0, 0, 1, 0],
					[0, 1, 1, 0],
					[0, 1, 0, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[1, 1, 0, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 1, 0],
					[0, 1, 1, 0],
					[0, 1, 0, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[1, 1, 0, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				]

			];

			l.color = "purple";
			l.rotations = [
				[
					[0, 1, 0, 0],
					[0, 1, 0, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 1, 1],
					[0, 1, 0, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 1, 1, 0],
					[0, 0, 1, 0],
					[0, 0, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 0, 1, 0],
					[1, 1, 1, 0],
					[0, 0, 0, 0]
				]

			];

			j.color = "lightblue";
			j.rotations = [
				[
					[0, 0, 1, 0],
					[0, 0, 1, 0],
					[0, 1, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 0, 0],
					[0, 1, 1, 1],
					[0, 0, 0, 0]
				],
				[
					[0, 1, 1, 0],
					[0, 1, 0, 0],
					[0, 1, 0, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[1, 1, 1, 0],
					[0, 0, 1, 0],
					[0, 0, 0, 0]
				]
			];


			t.color = "orange";
			t.rotations = [
				[
					[0, 0, 1, 0],
					[0, 1, 1, 1],
					[0, 0, 0, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 1, 0],
					[0, 0, 1, 1],
					[0, 0, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 0, 0],
					[0, 1, 1, 1],
					[0, 0, 1, 0],
					[0, 0, 0, 0]
				],
				[
					[0, 0, 1, 0],
					[0, 1, 1, 0],
					[0, 0, 1, 0],
					[0, 0, 0, 0]
				]
			];

			var pieces = {
				line: line,
				block: block,
				s: s,
				z: z,
				l: l,
				j: j,
				t: t
			};

			var piece = pieces[shape];
			piece.shape = shape;

			piece.currentRotation = 0;

			piece.rotate = function () {
				this.currentRotation = (this.currentRotation + 1) % 4;
				return this.currentRotation;
			};

			piece.getRotations = function (times) {
				// this is bad
				var dummyPiece = pieceFactory(this.shape);
				dummyPiece.coords = this.coords;
				dummyPiece.currentRotation = this.currentRotation;
				dummyPiece.rotate();
				return dummyPiece;

			};

			piece.getSingleRotation = function () {
				return this.getRotations(1);
			};

			piece.getGrid = function () {
				return this.rotations[this.currentRotation];
			};

			piece.getOccuppied = function () {
				var corner = this.coords;
				var grid = this.getGrid();

				var nestedObjectGrid = grid.map(function (row, rowOffset) {
					return row.map(function (box, colOffset) {
						return {
							isOccuppied: box,
							row: corner.row + rowOffset,
							col: corner.col + colOffset
						};
					});
				});

				var objectArr = flatten(nestedObjectGrid);

				var occuppiedObjectArr = objectArr.filter(function (square) {
					return square.isOccuppied;
				});

				return occuppiedObjectArr;

			};

			piece.coords = {
				row: 0,
				col: 0
			};

			piece.lower = function () {
				this.coords.row += 1;
				return this.coords.row;
			};

			piece.shift = function (direction) {
				this.coords.col += direction;
				return this.coords.col;
			};

			return piece;
		}

		pieceFactory.allShapes = ['line', 'block', 's', 'z', 'j', 'l', 't'];

		function gameBoardFactory (boardConfig) {
			var board = {};

			var model = boardModelFactory(boardConfig.rows, boardConfig.cols, boardConfig.squareModelFactory);

			board.getRandomPiece = getRandomPiece;
			board.getPiece = getPiece;

			board.freezePiece = freezePiece;
			board.getGrid = getGrid;
			board.getSquare = getSquare;
			board.getRow = getRow;
			board.getCol = getCol;
			board.pieceCanMove = pieceCanMove;
			board.pieceCanRotate = pieceCanRotate;

			board.currentPiece = board.getRandomPiece();

			function getRandomPiece () {
				var randomShape = randomFromArr(boardConfig.gamePieceFactory.allShapes);
				return getPiece(randomShape);
			}

			function getPiece (shape) {
				return boardConfig.gamePieceFactory(shape);
			}

			function freezePiece (piece) {
				piece.getOccuppied().forEach(function (square) {
					var gameBoardSquare = board.getSquare(square.row, square.col);
					gameBoardSquare.isOccuppied = true;
					gameBoardSquare.color = piece.color;
				});
			}

			function pieceWouldCollide (piece, rowOffset, colOffset) {
				var wouldCollide = piece.getOccuppied().some(function (pieceSquare) {
					var gridSquare = getSquare(pieceSquare.row + rowOffset, pieceSquare.col + colOffset);
					return gridSquare && gridSquare.isOccuppied;
				});

				return wouldCollide;
			}

			function isOffBoard (piece, rowOffset, colOffset) {
				var offBoard = piece.getOccuppied().some(function (pieceSquare) {
					return !getSquare(pieceSquare.row + rowOffset, pieceSquare.col + colOffset);
				});

				return offBoard;
			}

			function pieceCanRotate (piece) {
				var safeToRotate = pieceCanMove(piece.getSingleRotation(), 0, 0);
				return safeToRotate;
			}

			function pieceCanMove (piece, row, col) {
				var wouldCollide = pieceWouldCollide(piece, row, col);
				var wouldBeOffBoard = isOffBoard(piece, row, col);

				return (!wouldCollide && !wouldBeOffBoard);
			}

			function getGrid () {
				return model;
			}

			function getCol (col) {
				return model.map(function (row) {
					return row[col];
				});
			}

			function getRow (row) {
				return model[row];
			}

			function getSquare (row, col) {
				if (row >= boardConfig.rows || col >= boardConfig.cols) {
					return undefined
				}
				else {
					return model[row][col];
				}
			}

			function boardModelFactory (rows, cols, squareModelFactory) {
				squareModelFactory = (squareModelFactory || function () {return {}});

				var model = [];
				for (var r=0; r<rows; r++) {
					var row = [];
					for (var c=0; c<cols; c++) {
						var square = squareModelFactory(r, c);
						row.push(square);
					}
					model.push(row);
				}

				return model;
			}

			return board;
		}

		function viewFactory (viewConfig) {
			var view = {};

			var canvas = viewConfig.canvas;
			var context = canvas.getContext('2d');

			var height = canvas.height;
			var width = canvas.width;

			var rowsNumber = viewConfig.model.getRow(0).length;
			var colsNumber = viewConfig.model.getCol(0).length;

			var rowHeight = height / rowsNumber;
			var colWidth = width / colsNumber;

			view.renderBoard = renderBoard;
			view.renderRow = renderRow;
			view.renderCol = renderCol;
			view.renderPiece = renderPiece;
			view.wipeScreen = wipeScreen;

			function wipeScreen (color) {
				var cachedFillStyle = context.fillStyle;
				color = color || 'grey';
				context.fillStyle = color;
				context.fillRect(0, 0, width, height);
				context.fillStyle = cachedFillStyle;

			}

			function paintSquare (row, col, color) {
				var cachedFillStyle = context.fillStyle;
				context.fillStyle = color;
				context.fillRect(col*colWidth, row*rowHeight, colWidth, rowHeight);
				context.fillStyle = cachedFillStyle;
			}

			function renderBoard () {
				viewConfig.model.getGrid().forEach(function (row) {
					row.forEach(function (square) {
						paintSquare(square.row, square.col, square.color);
					});
				});
			}

			function renderRow (row) {
				var rowPieces = viewConfig.model.getRow(row);
				rowPieces.forEach(function (box) {
					paintSquare(box.row, box.col, box.color);
				});
			}

			function renderCol (col) {
				var colPieces = viewConfig.model.getCol(col);
				colPieces.forEach(function (box) {
					paintSquare(box.row, box.col, box.color);
				});
			}

			function renderPiece (piece) {
				var row = piece.coords.row;
				var col = piece.coords.col;
				var grid = piece.getGrid();

				grid.forEach(function (pieceRow, rowOffset) {
					pieceRow.forEach(function (boxPresent, colOffset) {
						if (boxPresent) {
							paintSquare(row+rowOffset, col+colOffset, piece.color);
						}
					});
				});
			}

			return view;
		}

		function squareModelFactory (row, col) {
			return {
				row: row,
				col: col,
				isOccuppied: false,
				color: 'grey'
			};
		}

		var canvas = document.getElementById('game-board');

		var gameBoard = gameBoardFactory({
			rows: 20,
			cols: 20,
			// nextPieceQueue: 4,
			squareModelFactory: squareModelFactory,
			gamePieceFactory: pieceFactory
		});

		var view = viewFactory({
			canvas: canvas,
			model: gameBoard
		});

		function gameControllerFactory (controllerConfig) {
			var controller = {};

			controller.start = start;

			var cyclesBlocked = 0;

			function runRender () {
				controllerConfig.view.wipeScreen();
				controllerConfig.view.renderBoard();
				controllerConfig.view.renderPiece(controllerConfig.model.currentPiece);
				window.requestAnimationFrame(runRender);
			}

			function start () {
				document.body.addEventListener('keydown', handleKeyDown);
				runRender();

				// this logic should be moved to gameModel
				window.setInterval(function () {
					if (!moveDown()) {
						cyclesBlocked += 1;
					}
					if (cyclesBlocked >= controllerConfig.freezePieceAfter) {

						controllerConfig.model.freezePiece(controllerConfig.model.currentPiece);
						cyclesBlocked = 0;
						controllerConfig.model.currentPiece = controllerConfig.model.getRandomPiece();
					}

				}, 500);


			}

			var keyCodeDict = {
				'37': 'left',
				'38': 'up',
				'39': 'right',
				'40': 'down',
				'32': 'space'
			};

			var actionsDict = {
				'left': moveLeft,
				'up': rotatePiece,
				'right': moveRight,
				'down': moveDown,
				'space': hardDrop
			};

			function handleKeyDown (key) {
				if (keyCodeDict[key.keyCode]) {
					key.preventDefault();
					// is binding to the controller necessary?
					actionsDict[keyCodeDict[key.keyCode]].call(controller);
				}
			}

			function moveLeft () {
				if (controllerConfig.model.pieceCanMove(controllerConfig.model.currentPiece, 0, -1)) {
					controllerConfig.model.currentPiece.shift(-1);
				}
			}

			function moveRight () {
				if (controllerConfig.model.pieceCanMove(controllerConfig.model.currentPiece, 0, 1)) {
					controllerConfig.model.currentPiece.shift(1);
				}
			}

			function rotatePiece () {
				if (controllerConfig.model.pieceCanRotate(controllerConfig.model.currentPiece)) {
					controllerConfig.model.currentPiece.rotate();
				}
			}

			function moveDown () {
				var ableToMove = controllerConfig.model.pieceCanMove(controllerConfig.model.currentPiece, 1, 0);

				if (ableToMove) {
					controllerConfig.model.currentPiece.lower();
				}

				return ableToMove;
			}

			function hardDrop () {
				while (moveDown()) {
					// drop until can't
				}

				controllerConfig.model.freezePiece(controllerConfig.model.currentPiece);
				cyclesBlocked = 0;
				controllerConfig.model.currentPiece = controllerConfig.model.getRandomPiece();
			}

			return controller;
		}

		var controller = gameControllerFactory({
			view: view,
			model: gameBoard,
			freezePieceAfter: 2
		});

		controller.start();

	</script>




</body>
</html>
